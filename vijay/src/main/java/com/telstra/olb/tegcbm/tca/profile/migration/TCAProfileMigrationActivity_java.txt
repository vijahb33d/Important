package com.telstra.olb.tegcbm.tca.profile.migration;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.LineNumberReader;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.telstra.olb.tegcbm.job.core.Activity;
import com.telstra.olb.tegcbm.job.core.ActivityException;
import com.telstra.olb.tegcbm.job.core.IContext;
import com.telstra.olb.tegcbm.tca.profile.migration.dao.TCAProfileMigrationDAO;

/**
 * Activity Class which does all the process for reading the TCA input filr and
 * generates the CSV for TCA profile migration.
 */
public class TCAProfileMigrationActivity implements Activity {

    private static final String CIDN_STR = "CIDN";

    private static final String ECSID_STR = "ECSID";

    private static final String START_TAG = "START";

    private static final String END_TAG = "END";

    private static final String QUOTE = "\"";

    private static final String COMMA = ",";

    private static final String OPEN = " (";

    private static final String CLOSE = ")";

    private static final String RECON_HEADER = "PROFILE RETRIEVAL DATE: ";

    private static final String SUCCEDED_CIDN = "SUCCEDED CIDN: ";

    private static final String FAILED_CIDN = "FAILED CIDN: ";

    private static final String DELIMITER = ",";

    private static final String RETAIL_CUSTOMER = "R";

    private static final String WHOLESALE_CUSTOMER = "W";

    private static final SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyyMMdd");

    private String directoryName;

    private String retailInputFileName;

    private String retailOutputFileName;

    private String retailReconFileName;

    private String wholesaleInputFileName;

    private String wholesaleOutputFileName;

    private String wholesaleReconFileName;

    private String name;

    private TCAProfileMigrationDAO pdbDAO;

    private TCAProfileMigrationDAO pdbwbvDAO;

    private String attribs;

    private String customerType;

    private final Log log = LogFactory.getLog(this.getClass());

    /**
     * Method triggers the execution of the entire process of capturing the
     * active users profile in the required format in CSV.
     * 
     * @param activityContext -
     *            Not used for any input, followed to adhere to the activity
     *            framework.
     * @throws ActivityException
     */
    public void execute(IContext activityContext) throws ActivityException {
        log.debug("tcaProfileMigration job executtion start");

        for (Iterator iter = activityContext.getPropertyNames().iterator(); iter.hasNext();) {
            String str = (String) iter.next();
            log.debug("Recognized Input Arg : " + str + "=" + activityContext.getProperty(str));
        }
        customerType = (String) activityContext.getProperty("customerType");
        if (customerType == null
                || (customerType != null && (customerType.trim().equalsIgnoreCase(RETAIL_CUSTOMER) || customerType.trim().equalsIgnoreCase(
                        WHOLESALE_CUSTOMER)))) {
            if (customerType == null || customerType.trim().equalsIgnoreCase(RETAIL_CUSTOMER)) {
                log.info("start processing Retail customers...");
                process(activityContext, getPdbDAO(), RETAIL_CUSTOMER);
                log.info("end processing Retail customers");
            }
            if (customerType == null || customerType.trim().equalsIgnoreCase(WHOLESALE_CUSTOMER)) {
                log.info("start processing Wholesale customers...");
                process(activityContext, getPdbwbvDAO(), WHOLESALE_CUSTOMER);
                log.info("end processing Retail customers");
            }
        } else {
            log.error("Invalid CustomerType: " + customerType);
        }
        log.debug("tcaProfileMigration job executtion end");
    }

    private void process(IContext activityContext, TCAProfileMigrationDAO dao, String customerType) throws ActivityException {
        log.debug("process start");
        List cidns = new ArrayList();
        List profiles = new ArrayList();
        List invalidCIDN = new ArrayList();
        try {
            cidns = readInputFile(customerType);
            if (cidns != null && !cidns.isEmpty()) {
                for (Iterator iter = cidns.iterator(); iter.hasNext();) {
                    String cidn = (String) iter.next();
                    Collection profileList = dao.retrieveParamsForCIDN(cidn);
                    if (profileList != null && !profileList.isEmpty()) {
                        profiles.addAll(profileList);
                    } else {
                        invalidCIDN.add(cidn);
                    }
                }
                if (!profiles.isEmpty()) {
                    writeProfileInfo(profiles, customerType);
                }
                writeReconInfo(cidns, invalidCIDN, customerType);
            } else if (cidns != null && cidns.isEmpty()) {
                log.info("Input File have no CIDN information");
            }
        } catch (Exception e) {
            throw new ActivityException("Exception occured while processing", e);
        }
        log.debug("process end");
    }

    /**
     * Method writes the User Profiles to the CSV in the required format.
     * 
     * @param profiles
     * @throws IOException
     * @throws IOException
     */
    private void writeProfileInfo(List profiles, String customerType) throws IOException {
        log.debug("writeProfileInfo start");
        String dateStr = dateFormatter.format(new Date());
        String outputFilePath = getDirectoryName() + dateStr + getOutputFileName(customerType);
        log.info("Output File Path : " + outputFilePath);
        PrintWriter writer = null;
        try {
            writer = new PrintWriter(new BufferedWriter(new FileWriter(outputFilePath)));
            writer.println(START_TAG);
            writer.println(getHeader());

            for (Iterator iter = profiles.iterator(); iter.hasNext();) {
                TCAUserProfile profile = (TCAUserProfile) iter.next();
                writer.println(profile.toString());
            }

            writer.print(END_TAG);
        } finally {
            if (writer != null)
                writer.close();
            log.debug("writeProfileInfo end");
        }
    }

    /**
     * Writes the recincilation information into CSV file.
     * 
     * @param profiles
     * @param invalidCIDN
     * @throws IOException
     */
    private void writeReconInfo(List cidns, List invalidCIDN, String customerType) throws IOException {
        log.debug("writeReconInfo start");
        String dateStr = dateFormatter.format(new Date());
        String outputFilePath = getDirectoryName() + dateStr + getReconFileName(customerType);
        log.info("Output File Path : " + outputFilePath);
        PrintWriter writer = null;
        try {
            writer = new PrintWriter(new BufferedWriter(new FileWriter(outputFilePath)));
            writer.println(START_TAG);
            writer.println(RECON_HEADER + dateStr);
            writer.println(SUCCEDED_CIDN + (cidns.size() - invalidCIDN.size()));
            writer.print(FAILED_CIDN + invalidCIDN.size());

            if (!invalidCIDN.isEmpty()) {
                writer.print(OPEN);
                for (Iterator iter = invalidCIDN.iterator(); iter.hasNext();) {
                    writer.print((String) iter.next());
                    if (iter.hasNext()) {
                        writer.print(COMMA);
                    }
                }
                writer.print(CLOSE);
            }
            writer.println();

            writer.print(END_TAG);
        } finally {
            if (writer != null)
                writer.close();
            log.debug("writeReconInfo end");
        }
    }

    /**
     * Method generates and returns the header to be written in the CSV,
     * utilises the attributes in the config file for this purpose.
     * 
     * @param profile
     * @return
     */
    private String getHeader() {
        StringBuffer sb = new StringBuffer();
        sb.append(QUOTE + CIDN_STR + QUOTE);
        sb.append(COMMA);
        sb.append(QUOTE + ECSID_STR + QUOTE);
        String[] attributes = getAttributes();
        for (int index = 0; index < attributes.length; index++) {
            sb.append(COMMA + QUOTE + StringUtils.upperCase(attributes[index]) + QUOTE);
        }
        return sb.toString();
    }

    /**
     * Method interpret the input file and returns an CIDN list.
     * 
     * @param file
     * @throws IOException
     */
    private List readInputFile(String customerType) throws IOException {
        log.debug("readInputFile start");
        List cidnList = null;
        LineNumberReader reader = null;
        String inputFilePath = getDirectoryName() + getInputFileName(customerType);
        log.info("Input File Path : " + inputFilePath);
        try {
            File inputFile = new File(inputFilePath);
            if (inputFile.exists()) {
                reader = new LineNumberReader(new BufferedReader(new FileReader(inputFile)));
                cidnList = new ArrayList();
                String lineRead = null;
                while ((lineRead = reader.readLine()) != null) {
                    lineRead = lineRead.trim();
                    if (reader.getLineNumber() == 1) {
                        if (lineRead.equals(START_TAG)) {
                            continue;
                        } else {
                            log.error("Invalid Data Format: " + lineRead + " on Line: " + reader.getLineNumber());
                            throw new IOException("Invalid Data Format: " + lineRead + " on Line: " + reader.getLineNumber());
                        }
                    } else if (lineRead.equals(END_TAG)) {
                        break;
                    } else {
                        if (StringUtils.isNotBlank(lineRead) && lineRead.length() == 10) {
                            cidnList.add(lineRead);
                        } else {
                            log.error("Invalid Data Format: " + lineRead + " on Line: " + reader.getLineNumber());
                            continue;
                        }
                    }
                }
            } else {
                log.info("Input File is missing in the following path : " + inputFilePath);
            }
        } catch (FileNotFoundException e) {
            log.error("Invalid Input File Path : " + inputFilePath);
            throw e;
        } finally {
            if (reader != null) {
                reader.close();
            }
            log.debug("readInputFile end");
        }
        return cidnList;
    }

    public Activity getNextActivity() {
        return null;
    }

    public Iterator getData(IContext activityContext) {
        return null;
    }

    public String getInputFileName(String customerType) {
        return (customerType.equals(RETAIL_CUSTOMER) ? getRetailInputFileName() : getWholesaleInputFileName());
    }

    public String getOutputFileName(String customerType) {
        return (customerType.equals(RETAIL_CUSTOMER) ? getRetailOutputFileName() : getWholesaleOutputFileName());
    }

    public String getReconFileName(String customerType) {
        return (customerType.equals(RETAIL_CUSTOMER) ? getRetailReconFileName() : getWholesaleReconFileName());
    }

    /**
     * @return Returns the name.
     */
    public String getName() {
        return name != null ? name.trim() : name;
    }

    /**
     * @param name
     *            The name to set.
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * @return Returns the retailInputFileName.
     */
    public String getRetailInputFileName() {
        return retailInputFileName != null ? retailInputFileName.trim() : retailInputFileName;
    }

    /**
     * @param retailInputFileName
     *            The retailInputFileName to set.
     */
    public void setRetailInputFileName(String retailInputFileName) {
        this.retailInputFileName = retailInputFileName;
    }

    /**
     * @return Returns the retailOutputFileName.
     */
    public String getRetailOutputFileName() {
        return retailOutputFileName != null ? retailOutputFileName.trim() : retailOutputFileName;
    }

    /**
     * @param retailOutputFileName
     *            The retailOutputFileName to set.
     */
    public void setRetailOutputFileName(String retailOutputFileName) {
        this.retailOutputFileName = retailOutputFileName;
    }

    /**
     * @return Returns the retailReconFileName.
     */
    public String getRetailReconFileName() {
        return retailReconFileName != null ? retailReconFileName.trim() : retailReconFileName;
    }

    /**
     * @param retailReconFileName
     *            The retailReconFileName to set.
     */
    public void setRetailReconFileName(String retailReconFileName) {
        this.retailReconFileName = retailReconFileName;
    }

    /**
     * @return Returns the wholesaleInputFileName.
     */
    public String getWholesaleInputFileName() {
        return wholesaleInputFileName != null ? wholesaleInputFileName.trim() : wholesaleInputFileName;
    }

    /**
     * @param wholesaleInputFileName
     *            The wholesaleInputFileName to set.
     */
    public void setWholesaleInputFileName(String wholesaleInputFileName) {
        this.wholesaleInputFileName = wholesaleInputFileName;
    }

    /**
     * @return Returns the wholesaleOutputFileName.
     */
    public String getWholesaleOutputFileName() {
        return wholesaleOutputFileName != null ? wholesaleOutputFileName.trim() : wholesaleOutputFileName;
    }

    /**
     * @param wholesaleOutputFileName
     *            The wholesaleOutputFileName to set.
     */
    public void setWholesaleOutputFileName(String wholesaleOutputFileName) {
        this.wholesaleOutputFileName = wholesaleOutputFileName;
    }

    /**
     * @return Returns the wholesaleReconFileName.
     */
    public String getWholesaleReconFileName() {
        return wholesaleReconFileName != null ? wholesaleReconFileName.trim() : wholesaleReconFileName;
    }

    /**
     * @param wholesaleReconFileName
     *            The wholesaleReconFileName to set.
     */
    public void setWholesaleReconFileName(String wholesaleReconFileName) {
        this.wholesaleReconFileName = wholesaleReconFileName;
    }

    /**
     * @return Returns the directoryName.
     */
    public String getDirectoryName() {
        return directoryName != null ? directoryName.trim() : directoryName;
    }

    /**
     * @param directoryName
     *            The directoryName to set.
     */
    public void setDirectoryName(String directoryName) {
        this.directoryName = directoryName;
    }

    /**
     * Method splits the necessary attributes(from a String to a String array)
     * to be included as part of the profile.
     * 
     * @return
     */
    private final String[] getAttributes() {
        return getAttribs().split(DELIMITER);
    }

    public String getAttribs() {
        return attribs != null ? attribs.trim() : attribs;
    }

    public void setAttribs(String attribs) {
        this.attribs = attribs;
    }

    /**
     * @return Returns the pdbDAO.
     */
    public TCAProfileMigrationDAO getPdbDAO() {
        return pdbDAO;
    }

    /**
     * @param pdbDAO
     *            The pdbDAO to set.
     */
    public void setPdbDAO(TCAProfileMigrationDAO pdbDAO) {
        this.pdbDAO = pdbDAO;
    }

    /**
     * @return Returns the pdbwbvDAO.
     */
    public TCAProfileMigrationDAO getPdbwbvDAO() {
        return pdbwbvDAO;
    }

    /**
     * @param pdbwbvDAO
     *            The pdbwbvDAO to set.
     */
    public void setPdbwbvDAO(TCAProfileMigrationDAO pdbwbvDAO) {
        this.pdbwbvDAO = pdbwbvDAO;
    }
}